extends ../presentation-template

block theme
    - themeName = "scalac"

block title
    | ActorRef[Typed]

block slides
    +titleSlide("ActorRef[Typed]", true, false)

    +justSentence("What is the most valuable thing in Scala?")

    +justSentence("Type system")

    +justSentence("What does Akka Actors offer?")

    +justSentence
        pre PartialFunction[Any, Unit]

    +justSentence("And now imagine a new dev in project")

    +slide(class="to-middle")
        h2
            pre Ctrl+F
            | &nbsp;based navigation

        pre: code.scala.
            class BlockImporter(blockFetcher: ActorRef) extends Actor {
              blockFetcher ! ???
            }

    +justSentence("Mutable-by-default API")

    +justSentence("Will you spot the error?")

    +slide
        pre: code.lang-scala.
            class BlockImporter extends Actor {
              var importedBlocks: List[Block] = Nil

              val importBlocks: List[Block] => Future[Unit]

              def receive = {
                case ImportBlocks(blocks) =>
                  importBlocks(blocks)
                    .onComplete(_ =>
                      importedBlocks = importedBlocks ++ blocks
                    )
              }
            }

    +slide
        pre
            code.nohighlight.dimmed.
                class BlockImporter extends Actor {
                  var importedBlocks: List[Block] = Nil

                  val importBlocks: List[Block] => Future[Unit]

                  def receive = {
                    case ImportBlocks(blocks) =>
                      importBlocks(blocks)
                        .onComplete(_ =>

            code.nohighlight.highlighted.
                &nbsp;           importedBlocks = importedBlocks ++ blocks

            code.nohighlight.dimmed.
                &nbsp;     )
                }
              }

    +slide
        pre: code.lang-scala.
            def receive = running(Nil)

            def running(importedBlocks: List[Block]) = {
              case ImportBlocks(blocks) =>
                importBlocks(blocks)
                  .onComplete(_ =>
                    context become running(importedBlocks ++ blocks))
            }

    +slide
        pre
            code.nohighlight.dimmed.
                def receive = running(Nil)

                def running(importedBlocks: List[Block]) = {
                  case ImportBlocks(blocks) =>
                    importBlocks(blocks)
                      .onComplete(_ =>

            code.nohighlight.highlighted.
                &nbsp;       context become running(importedBlocks ++ blocks))

            code.nohighlight.dimmed.
                }

    +slide
        pre: code.lang-scala.
            def receive = notImportingBlocks(Nil)

            def notImportingBlocks(importedBlocks: List[Block]) = {
              case ImportBlocks(blocks) =>
                context become importingBlocks(importedBlocks)
                importBlocks(blocks)
                  .map(_ => BlocksImportCompleted(blocks))
                  .pipeTo(self)
            }

            def importingBlocks(importedBlocks: List[Block]) = {
              case BlocksImportCompleted =>
               context become notImportingBlocks(importedBlocks ++ blocks)
            }

    // Is it needed?
    //+slide
    //    h2 Current state is a left fold of events

    //+slide
    //    pre: code.lang-scala.
    //        val replayEvent: (State, Event) => State
    //        val initialState: State
    //
    //        val state = events.foldLeft(initialState)(replayEvent)

    +justSentence
        h2 Say hello to&nbsp;
            pre Behavior[T]

    +slide
        pre: code.lang-scala.
            package akka.actor.typed.scaladsl

            object Behaviors {
              def receive[T](
                onMessage: (ActorContext[T], T) ⇒ Behavior[T]
              ): Behavior[T]

              def receiveMessage[T](
                onMessage: T ⇒ Behavior[T]
              ): Behavior[T]
            }


    +justSentence("In practice it looks as follows:")

    +justSentence("Define your protocol")

    +slide
        pre: code.lang-scala.
            sealed trait BlockImporterMsg

            case class ImportBlocks(
              blocks: List[Block],
              respondTo: ActorRef[BlocksImported]) extends BlockImporterMsg
            case class BlocksImported(blocks: List[Block])

            case class BlocksImportCompleted(blocks: List[Block]) extends BlockImporterMsg

    +justSentence("Define the behavior")

    +slide
        pre: code.lang-scala.
            object BlockImporter {
              def behavior(importedBlocks: List[Block] = Nil): Behavior[BlockImporterMsg] =
                Behaviors.receive((ctx, msg) =>
                  msg match {
                    case ImportBlocks(blocks, respondTo) =>
                      importBlocks(blocks)
                        .onComplete(_ => {
                          respondTo ! BlocksImported(blocks)
                          ctx.self ! BlocksImportCompleted(blocks)
                        })
                      Behaviors.same
                    case BlocksImportCompleted =>
                      behavior(importedBlocks ++ blocks)
                  }
            }

    +justSentence("Now the guardian...")

    +slide
        pre: code.lang-scala.
            object Guardian {
              case object Start

              def behavior = Behaviors.setup[Start.type]{ ctx =>
                val importer: ActorRef[BlockImporterMsg] = ctx.spawn(BlockImporter.behavior(), "block-importer")

                Behaviors.receiveMessage {
                  case Start =>
                    importer ! ImportBlocks(blocks)
                    Behaviors.same
                }
              }
            }

    +slide
        pre: code.lang-scala.
            object Guardian {
              def behavior = SpawnProtocol.behavior
            }


    +justSentence("And the system")

    +slide
        pre: code.lang-scala.
            import akka.actor.typed.ActorSystem

            object Main extends App {
              val system = ActorSystem(Guardian.behavior, "guardian")

              system ! Guardian.Start
            }

    +justSentence
        div
            h2 Wait! Nice "hello, world"
            h2 but I need...

    +justSentence("Logging?")

    +slide
        pre: code.lang-scala.
            Behaviors.logMessages(otherBehavior)

    +slide
        pre: code.lang-scala.
            def behavior: Behavior[SomeMsg] =
              Behaviors
                .intercept(
                  LoggingInterceptor[SomeMsg]())(
                  otherBehavior)

    +slide
        pre: code.lang-scala.
            class LoggingInterceptor[M] extends BehaviorInterceptor[M, M] {

              def aroundReceive(ctx: ActorContext[M], msg: M, target: BehaviorInterceptor.ReceiveTarget[M]): Behavior[M] = {
                ctx.asScala.log.debug("Message {}", msg)
                target(ctx, msg)
              }

              def aroundSignal(ctx: ActorContext[M], signal: Signal, target: BehaviorInterceptor.SignalTarget[M]): Behavior[M] = {
                ctx.asScala.log.debug("Signal {}", signal)
                target(ctx, signal)
              }
            }

    +justSentence("Supervision?")

    +slide
        pre: code.lang-scala.
            Behaviors
              .supervise(otherBehavior)
              .onFailure(SupervisorStrategy.restart)

    +justSentence("To handle actor lifecycle?")

    +slide
        pre: code.lang-scala.
            Behaviors
              .receive(/* ... */)
              .receiveSignal {
                case (_, PostStop) => //PreRestart, Terminated
                  //cleanup
                  Behaviors.same
              }

    +justSentence("Managing time?")

    +slide
        pre: code.lang-scala.
            val receive = Behaviors.receiveMessage {
              case CheckPeers =>
                //doSth
                Behaviors.same
            }

            Behaviors.withTimers(timers => {
              timers.startPeriodicTimer(
                "check-peers",
                CheckPeers,
                10.seconds)

                receive
            })

    +justSentence("And there's always...")

    +slide
        pre: code.lang-scala.
            package akka.actors.typed

            abstract class ExtensibleBehavior[T] extends Behavior[T] {

              def receive(ctx: TypedActorContext[T], msg: T): Behavior[T]

              def receiveSignal(ctx: TypedActorContext[T], msg: Signal): Behavior[T]
            }


    +finalSlides
